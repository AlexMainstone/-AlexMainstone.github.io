<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://alexmainstone.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://alexmainstone.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-08-28T11:24:41+00:00</updated><id>https://alexmainstone.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Voronoi Graphics: Drawing shapes across voronoi edges</title><link href="https://alexmainstone.github.io/blog/2019/Voronoi-Graphics/" rel="alternate" type="text/html" title="Voronoi Graphics: Drawing shapes across voronoi edges"/><published>2019-12-22T14:37:40+00:00</published><updated>2019-12-22T14:37:40+00:00</updated><id>https://alexmainstone.github.io/blog/2019/Voronoi-Graphics</id><content type="html" xml:base="https://alexmainstone.github.io/blog/2019/Voronoi-Graphics/"><![CDATA[<p>Today I generated and drew onto a voronoi diagram using the <a href="https://github.com/mdally/Voronoi">Voronoi</a> (mdally/Voronoi) library.</p> <h2 id="generating-the-diagram">Generating the diagram</h2> <p>The first thing I’d have to do is generate a voronoi diagram, this can be done as follows.</p> <h3 id="generate-random-points">Generate random points</h3> <p>First up I just generate a set of random points across a set area, I generated 10,000 points across an area of 1280x720.</p> <h3 id="apply-fortunes-algorithm-using-the-voronoi-library">Apply Fortunes algorithm using the voronoi library</h3> <p>Using the library’s VoronoiDiagramGenerator, I can pass it the sites, and a box which will provide the edges of our diagram (again being 1280x720).</p> <h3 id="lloyds-relaxtion">Lloyds Relaxtion</h3> <p>We then use the library to apply Lloyds Relaxation to our voronoi, which simply runs fortunes algorithm across all the cell sites in the previous voronoi, this will generate a slightly more organized voronoi diagram.</p> <h2 id="generating-shapes">Generating Shapes</h2> <p>Next we can generate shapes across this diagram, this will be done by giving each cell a struct containing their altitude (more info to aid with world generation can be added later), if their altitude is 0 it’s water otherwise it is land. We store this cell data in a map, using cells as the key to this map.</p> <p><code class="language-plaintext highlighter-rouge">std::map&lt;Cell*, MapCell*&gt; cellproperties;</code></p> <h3 id="drawing-the-intersections-between-water-and-land">Drawing the intersections between water and land</h3> <p>Finally, to find the edges to draw, we iterate through every edge in the diagram, if one of the cells on either the left or right isn’t 0 and the other is 0 then we add the line to a sf::VertexArray that draws lines.</p> <p><img src="https://imgur.com/2d38bab6-a253-436c-82b4-e49d3073195a" alt="Voronoi circle"/></p>]]></content><author><name></name></author><category term="gamedev"/><category term="maths"/><summary type="html"><![CDATA[Generate 2d map terrain on voronoi diagrams]]></summary></entry><entry><title type="html">Markov Chains</title><link href="https://alexmainstone.github.io/blog/2019/Markov-Chains/" rel="alternate" type="text/html" title="Markov Chains"/><published>2019-12-19T18:26:22+00:00</published><updated>2019-12-19T18:26:22+00:00</updated><id>https://alexmainstone.github.io/blog/2019/Markov-Chains</id><content type="html" xml:base="https://alexmainstone.github.io/blog/2019/Markov-Chains/"><![CDATA[<p>I have been working on generating random world maps and decided to give name generation a shot. I now have a header file that can be fed words to generate new words using the input as a dataset.</p> <h2 id="forming-a-dataset">Forming a dataset</h2> <p>It should be noted first that I will be using <code class="language-plaintext highlighter-rouge">n</code> to represent the number of letters we are storing as our key in the map.</p> <p>First things first, we need to generate a dataset, to store this dataset I used the following variable:</p> <p><code class="language-plaintext highlighter-rouge">map&lt;string, vector&lt;pair&lt;int char&gt;&gt;&gt; markov_data</code></p> <p>Which means we access it as follows:</p> <p><code class="language-plaintext highlighter-rouge">following_letter_frequency = markov_data[N-LETTER PAIR]</code></p> <p>So for each n-letters we store every possible character that comes after, we store this in a pair with an integer that we can incrememt to represent the frequency in which this character appears after the n-letters.</p> <p>So, I loop through the input data, take every n-sets of letters and store the following letter in the corresponding pair vector.</p> <h2 id="creating-new-data">Creating new data</h2> <p>Now, all we have to do is get a random key for our map as our start, then pick the next letters to come after our current last <code class="language-plaintext highlighter-rouge">n</code> letters, we do this an appropriate amount of times to create reasonably sized names (4-9ish). I decided to ensure that the random start decided by the key always has at least vowel, as I didn’t think names like that looked right.</p> <h2 id="output">Output</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eyci
adee
rallech
vamelc
ecari
uend
tunnid
ubinesig
verina
eital
xinah
iphilda
uzylysph
ierta
</code></pre></div></div>]]></content><author><name></name></author><category term="AI"/><category term="gamedev"/><category term="maths"/><summary type="html"><![CDATA[Generating Fantasy city names with Markov chains]]></summary></entry><entry><title type="html">AI For Games: Week 11</title><link href="https://alexmainstone.github.io/blog/2018/AI-week-11/" rel="alternate" type="text/html" title="AI For Games: Week 11"/><published>2018-12-09T14:39:35+00:00</published><updated>2018-12-09T14:39:35+00:00</updated><id>https://alexmainstone.github.io/blog/2018/AI-week-11</id><content type="html" xml:base="https://alexmainstone.github.io/blog/2018/AI-week-11/"><![CDATA[<h3 id="retrospective--user-survey">Retrospective &amp; User Survey</h3> <p>This week I’ll express my thoughts on my own work as well as asking others.</p> <h2 id="my-retrospective">My Retrospective</h2> <p>Overall, I’m happy with my final work for the assignment, I don’t think it’s by any means a good game, but it demonstrates my understanding of Artificial Intelligience for Games effectively. If I were to continue developming this game I think the first thing I’d do is make the file structure of my Godot project more coherent and understandable, I’d also add basic features of a game such as an ending, menu etc. I think my game is also distinctly lacking ‘game juice’ it feels really cold and static, camera shakes and smoother camera movement, colour and more advanced enemy reactions would really make my game more ‘juicy’. A more consistent art style would be nice too, not a mash of assets I found online. Finally, some more gameplay features:</p> <ul> <li>Random levels</li> <li>Destroying enemies</li> <li>Distraction tools</li> <li>Movement tools (teleportation etc)</li> <li>AI learning perhaps like Metal Gear Solid V where enemies wear helmets if you use too many headshots etc.</li> </ul> <h2 id="user-survey">User Survey</h2> <p>I asked a few (10) friends and family to take a look at my game, and then quizzed them afterwards. Here are the results</p> <h3 id="do-you-think-i-made-good-use-of-ai-in-my-game-y-8-n-2">Do you think I made good use of AI in my game? (y: 8, n: 2)</h3> <p>People generally thought that yes I had. I got 2 ‘no’ answers, here are the reasons I got when I enquired:</p> <ul> <li>Bad positioning of enemies</li> <li>Enemies don’t look for the player, they just go to where they last saw them</li> <li>The queen doesn’t seem like a genuine threat</li> </ul> <h3 id="were-the-controls-intuitive-y-7-n-3">Were the controls intuitive? (y: 7, n: 3)</h3> <p>It’s pretty standard controls so I expected this response, The little negative feedback was from people who don’t really play games.</p> <ul> <li>No tutorial</li> </ul> <h3 id="was-my-game-fun-y-3-n-7">Was my game fun? (y: 3, n: 7)</h3> <p>I got an overall negative response to this:</p> <ul> <li>Game was too easy</li> <li>Not much player interaction with enemies and environment</li> <li>Enemies aren’t a real threat</li> <li>Very little to do</li> </ul> <h3 id="additional-thoughts">Additional thoughts?</h3> <ul> <li>Game is ugly</li> <li>Player is a bit stiff</li> <li>Add weapons</li> <li>Add more levels</li> <li>Add a menu and ui</li> <li>A hp system</li> <li>Remove the queen</li> </ul>]]></content><author><name></name></author><category term="AI"/><category term="gamedev"/><summary type="html"><![CDATA[Eleventh week of undergrad AI gamedev course]]></summary></entry><entry><title type="html">AI For Games: Week 10</title><link href="https://alexmainstone.github.io/blog/2018/AI-week-10/" rel="alternate" type="text/html" title="AI For Games: Week 10"/><published>2018-12-02T14:20:10+00:00</published><updated>2018-12-02T14:20:10+00:00</updated><id>https://alexmainstone.github.io/blog/2018/AI-week-10</id><content type="html" xml:base="https://alexmainstone.github.io/blog/2018/AI-week-10/"><![CDATA[<h3 id="bug-fixing">Bug fixing</h3> <p>I spent the final week fixing bugs! I also added a visual representation of the last known location</p> <h2 id="last-known-location">Last Known location</h2> <p>Each enemy holds a last known location model that becomes visible when they cant see the player but are suspicious, its position is set to the last place they saw the player.</p> <h2 id="bugs">Bugs</h2> <h3 id="movement-bug">Movement bug</h3> <p>I encountered a bug where the enemies moved really jerky, I figured out the fix was having a static interpolation point instead of using the players position, but the jerkeyness reminded me of chess pieces so I thought why not make the enemies of my game chess pieces! So this bug became a feature.</p> <h3 id="rotation-bug">Rotation bug</h3> <p>When the enemy rotated it rotated the ray that is cast, for this one I just set the rotation of the ray to 0 when I rotate the enemy.</p> <h3 id="pathfinding-bug">Pathfinding bug</h3> <p>A mixup in global and local coordinates caused all enemies to move to the same point when the player was spotted. I just switched the local position to global position when getting the path to the player and it fixed it.</p> <h3 id="enemies-spotting-the-player-through-walls">Enemies spotting the player through walls</h3> <p>When the enemies when from suspicious to calm they would spot players, this is because of a bug where it wasnt checking if it could see players when the enemy was slightly suspicous but couldn’t see them, causing the detection meter to rise.</p> <h3 id="player-would-get-stuck-on-walls">Player would get stuck on walls</h3> <p>I used the move_and_collide method instead of the move_and_slide, move and slide moves the player along the object on collision, allowing it to move while touching walls.</p> <h3 id="player-would-stop-while-changing-direction">Player would stop while changing direction</h3> <p>This was because I was setting my movement vector to 0 after every key release, not checking if another key was using it.</p> <h2 id="conclusion">Conclusion</h2> <p>These were all the bugs I found, there are probably more as there are with every game, but I’m happy with how much I fixed. And other ones are not blatantly obvious so they’re less of an issue.</p>]]></content><author><name></name></author><category term="AI"/><category term="gamedev"/><summary type="html"><![CDATA[Tenth week of undergrad AI gamedev course]]></summary></entry><entry><title type="html">AI For Games: Week 9</title><link href="https://alexmainstone.github.io/blog/2018/AI-week-9/" rel="alternate" type="text/html" title="AI For Games: Week 9"/><published>2018-11-25T17:44:19+00:00</published><updated>2018-11-25T17:44:19+00:00</updated><id>https://alexmainstone.github.io/blog/2018/AI-week-9</id><content type="html" xml:base="https://alexmainstone.github.io/blog/2018/AI-week-9/"><![CDATA[<h3 id="our-3d-models">Our 3D models</h3> <p>I realised that I never went over the import of our 3D models. So I’ll be doing that this week</p> <h2 id="chess-pieces">Chess pieces</h2> <p><img src="https://i.imgur.com/9m7USnM.png" alt="Chess"/> The chess pieces are untextured, I found a model for each chess piece and I opened it up in blender, deleted some objects like the camera and light source and then expoted it as a .DAE file, which is the only type of model that godot can recognise, which is really annoying for me. Then I just converted the .dae files to godot scenes in editor and voila! Our chess pieces are now in game.</p> <h2 id="player">Player</h2> <p><img src="https://i.imgur.com/cGGyVV9.jpg" alt="mixamo"/> The player was the biggest pain, first up finding a human rigged model was a pain, but I found a great resource for this:</p> <p>https://www.mixamo.com/#/</p> <p>Mixamo lets me export the model as a .DAE file, unfortunately I can only export the model with a single animation at a time, so I found myself copying the models into the editor multiple times and then copying the animation using godot and pasting them all into one model’s AnimationPlayer node. I decided that the textured model didnt really fit the games simplistic asthetic, so I decided to just make him green.</p> <h2 id="the-gridmap-tiles">The gridmap tiles</h2> <p>I used some minecraft textures in the gridmap to give the scene some variety. Simple but effective.</p> <p><img src="https://i.imgur.com/H8F2okX.png" alt="Cobblestone"/></p>]]></content><author><name></name></author><category term="AI"/><category term="gamedev"/><summary type="html"><![CDATA[Ninth week of undergrad AI gamedev course]]></summary></entry><entry><title type="html">AI For Games: Week 8</title><link href="https://alexmainstone.github.io/blog/2018/AI-week-8/" rel="alternate" type="text/html" title="AI For Games: Week 8"/><published>2018-11-18T18:11:22+00:00</published><updated>2018-11-18T18:11:22+00:00</updated><id>https://alexmainstone.github.io/blog/2018/AI-week-8</id><content type="html" xml:base="https://alexmainstone.github.io/blog/2018/AI-week-8/"><![CDATA[<h3 id="enemy-patrols">Enemy Patrols</h3> <p>I’m going to make the rooks patrol the map.</p> <h2 id="goal">Goal</h2> <p>My goal is to have enemies move along a path to form a ‘patrolling’ effect. I have planned this from the start but not yet implemented it, finally I can get around to it.</p> <h2 id="methods">Methods</h2> <p>Godot has a path node that I can draw paths in editor for my enemies to follow, but instead I’ll just place a target node and have the enemy pathfind there. It’s a lot less editor work and it’s the same amount of code to do it my way.</p> <h2 id="a-patrol-path">A patrol path</h2> <p>So, in our world scene we’ll add a load of enemies and a load of nodes that mark where the enemy will be patroling to. The enemy will patrol between its starting location and its closest patrol point. So, we use godot’s linear interpolation function to interpolate between the position of the enemy and the target node, when the interpolation is done we move on to the next point.</p> <h2 id="navigation-nodes">Navigation nodes</h2> <p>We have to make a load of nodes the player can navigate to, so I make a parent node which the rooks get from and they look through the children of that node until it finds the closest one to it. Perhaps I should manually select which node they navigate to so they can have overlapping or distant paths.</p> <h2 id="conclusion">Conclusion</h2> <p>My enemies now patrol the map! This will really add some more tension and complexity.</p>]]></content><author><name></name></author><category term="AI"/><category term="gamedev"/><summary type="html"><![CDATA[Eighth week of undergrad AI gamedev course]]></summary></entry><entry><title type="html">AI For Games: Week 7</title><link href="https://alexmainstone.github.io/blog/2018/AI-week-7/" rel="alternate" type="text/html" title="AI For Games: Week 7"/><published>2018-11-11T16:52:01+00:00</published><updated>2018-11-11T16:52:01+00:00</updated><id>https://alexmainstone.github.io/blog/2018/AI-week-7</id><content type="html" xml:base="https://alexmainstone.github.io/blog/2018/AI-week-7/"><![CDATA[<h3 id="adding-enemies-to-the-map">Adding enemies to the map</h3> <p>This week I placed my enemies and player in my world environment.</p> <h2 id="placement">Placement</h2> <p><img src="https://i.imgur.com/t2xrvad.png" alt="World"/></p> <h3 id="rooks">Rooks</h3> <p>The rooks have been spaced out pretty sparsely in all but the last room. I want to be able to show off the rooks in an environment where nothing else will kill me so the first one is good for that.</p> <h3 id="the-queen">The Queen</h3> <p>The queen starts right behind the player, she’s a threat right from the start!</p> <h3 id="pawns">Pawns</h3> <p>The pawns are placed in such a way that they wont be a threat until halfway through the level. There’s also an overhang before the final room that stops them following you.</p> <h2 id="some-other-minor-changes">Some other minor changes</h2> <ul> <li>I added arrows to the rooks so that you can tell what direction they’re facing</li> <li>I added torches to the map</li> <li>I added music but then disabled it immediately because it became annoying.</li> <li>I tinkered with the worldenvironment, this made the background black</li> </ul>]]></content><author><name></name></author><category term="AI"/><category term="gamedev"/><summary type="html"><![CDATA[Seventh week of undergrad AI gamedev course]]></summary></entry><entry><title type="html">AI For Games: Week 6</title><link href="https://alexmainstone.github.io/blog/2018/AI-week-6/" rel="alternate" type="text/html" title="AI For Games: Week 6"/><published>2018-11-04T16:23:57+00:00</published><updated>2018-11-04T16:23:57+00:00</updated><id>https://alexmainstone.github.io/blog/2018/AI-week-6</id><content type="html" xml:base="https://alexmainstone.github.io/blog/2018/AI-week-6/"><![CDATA[<h3 id="enemy-types">Enemy Types</h3> <p>I decided my game was rather tame, so to increase tension I’ll add a couple new enemy types.</p> <h2 id="the-pawn">The Pawn</h2> <p><img src="https://i.imgur.com/ND6y0oE.png" alt="Pawn"/> The pawn moves straight at the player, meaning there is no pathfinding, but they’re faster than the player meaning that the player has to use the environment to shake them off. For the movement I just interpolate the pawn’s position with the players. Easy and simple!</p> <h2 id="the-queen">The Queen</h2> <p><img src="https://i.imgur.com/jrE2tb0.png" alt="Queen"/> I wanted the player to always to be in danger, which is why I added the queen. The queen chases the player through the level, not the fastest enemy but it’s a looming threat that the player has to take into consideration while waiting for a rook to finish its patrol.</p> <h2 id="conclusion">Conclusion</h2> <p>I havent added the most content this week, but these 2 enemies introduce some important diversity to gameplay.</p>]]></content><author><name></name></author><category term="AI"/><category term="gamedev"/><summary type="html"><![CDATA[Sixth week of undergrad AI gamedev course]]></summary></entry><entry><title type="html">AI For Games: Week 5</title><link href="https://alexmainstone.github.io/blog/2018/AI-week-5/" rel="alternate" type="text/html" title="AI For Games: Week 5"/><published>2018-10-28T16:15:09+00:00</published><updated>2018-10-28T16:15:09+00:00</updated><id>https://alexmainstone.github.io/blog/2018/AI-week-5</id><content type="html" xml:base="https://alexmainstone.github.io/blog/2018/AI-week-5/"><![CDATA[<h3 id="developing-the-ai">Developing the AI</h3> <p>The AI will take up the same scene structure as our player, the differences will appear in the script.</p> <h2 id="the-script">The script</h2> <p>Godot returns paths along a navigation map in the form of an array of vectors. To make our enemy move along paths we simply have it interpolate between each point until it reaches the end of the path. <img src="https://i.imgur.com/KknbLTf.png" alt="Enemy"/></p> <h3 id="spotting-the-player">Spotting the player</h3> <p>Next up, we’ll have the enemy look to see if they can see the player. For this we just draw a ray between the enemy and the player, if it hits nothing then it can see the player. This is almost done, but we want the enemy to only be able to see in front of it, so we get the angle between the two points and add the rotation of the enemy, if its within 120 degrees of the enemies front then the enemy can see the player.</p> <p>Now we can increment a counter to determine the level of detection the enemy is in. If it has seen the player for a second then the enemy will look at the player, if it can see the player for longer the enemy will try to shoot the player (meaning if it sees it for a few seconds the player will die). Finally, if the enemy has detected the player, it will store the position the player was in before the enemy stops being able to see the player, the enemy will then move to that position.</p> <p>These behaviours make the enemy seem more realistic, without this code the enemy would just know instantly where the player is. This can also be called “Artificial Stupidity”</p> <h2 id="multiple-steering-behaviours--finite-state-machine">Multiple steering behaviours &amp; Finite State Machine</h2> <p>So my system implements a finitie state machine, they do go hand in hand. The Finite state machine consists of enums stating what the enemy is doing, if it’s SUSPICIOUS or CALM. The steering behaviours are what the enemy is doing, be it investigating the last known location of the player, attempting to kill it or simply patrolling between the nodes. The finite state machine is dictated by wether or not the enemy can see the player.</p> <p>Here’s the important code for the finite state machine:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	# Finite state machine
	if canSee:
		if state == CALM:
			# increase detection based on distance to player
			detection += delta * (15 - ppos.distance_to(pos))
			# increase size of '?' image under rook
			alert.region_rect.size.y = int(detection);
			
			# if detected enough, look at player
			if detection &gt;= 4:
				detection += delta*4
				look_at(Vector3(ppos.x, 0, ppos.z), Vector3(0, 1, 0))
				rotate_object_local(Vector3(0,1,0), deg2rad(180))
			# up state to suspicious if seen for long enough
			if detection &gt;= 16: 
				state = SUSPICIOUS
				path = null
				pathProgress = 0
				pathPoint = 0
				alert.modulate = Color(1, 1, 0)
		elif state == SUSPICIOUS:
			# look at player
			look_at(Vector3(ppos.x, 0, ppos.z), Vector3(0, 1, 0))
			rotate_object_local(Vector3(0,1,0), deg2rad(180))
			
			
			detection = 16
			alert.region_rect.size.y = int(detection);
			
			# always move last known location
			lastKnown = ppos
			lastloc.hide()
			
			# dont pathfind
			path = null
			pathProgress = 0
			pathPoint = 0
			
			# aim and kill player
			aimtimer += delta
			if aimtimer &gt; 2:
				get_node("/root/testworld").queue_free()
	else:
		if state == CALM:
			# create path if none, switching between 2 points
			if path == null:
				if endPoint:
					path = get_node("/root/testworld/Navigation").get_simple_path(transform.origin, startPos, false)
				else:
					path = get_node("/root/testworld/Navigation").get_simple_path(transform.origin, endPath, false)
				endPoint = !endPoint
				# remove y axis
				for i in range(0, path.size()):
					path[i].y = 0;
			
			#move along path
			if pathProgress &gt;= 1 and pathPoint &lt; len(path)-1:
				pathPoint+=1;
				pathProgress = 0;
			elif pathPoint &gt;= len(path)-1:
				pathProgress = 0
				pathPoint = 0
				path = null
			pathProgress += 0.05
			if path != null:
				transform.origin = transform.origin.linear_interpolate(path[pathPoint], pathProgress)
			
			# lower detection to 0
			if detection &gt; 0:
				detection -= 2*delta
				alert.region_rect.size.y = int(detection);
			
		elif state == SUSPICIOUS:
			# can't see, reset aim timer
			aimtimer = 0
			
			# look at last known location
			look_at(Vector3(lastKnown.x, 0, lastKnown.z), Vector3(0, 1, 0))
			rotate_object_local(Vector3(0,1,0), deg2rad(180))
			lastloc.show();
			
			# create path to last location if none
			if path == null:
				path = get_node("/root/testworld/Navigation").get_simple_path(transform.origin, lastKnown, false)
				# remove y axis
				for i in range(0, path.size()):
					path[i].y = 0;
			
			# move towards last location
			if pathProgress &gt;= 1 and pathPoint &lt; len(path)-1:
				pathPoint+=1;
				pathProgress = 0;
			elif pathPoint &gt;= len(path)-1:
				detection = 0
			pathProgress += 0.05
			transform.origin = transform.origin.linear_interpolate(path[pathPoint], pathProgress)
			
			# lowerr detection
			detection -= delta
			alert.region_rect.size.y = int(detection);
			if detection &lt;= 0:
				state = CALM
				alert.modulate = Color(0, 1, 0)
				lastloc.hide()
</code></pre></div></div>]]></content><author><name></name></author><category term="AI"/><category term="gamedev"/><summary type="html"><![CDATA[Fifth week of undergrad AI gamedev course]]></summary></entry><entry><title type="html">AI For Games: Week 4</title><link href="https://alexmainstone.github.io/blog/2018/AI-week-4/" rel="alternate" type="text/html" title="AI For Games: Week 4"/><published>2018-10-21T16:08:35+00:00</published><updated>2018-10-21T16:08:35+00:00</updated><id>https://alexmainstone.github.io/blog/2018/AI-week-4</id><content type="html" xml:base="https://alexmainstone.github.io/blog/2018/AI-week-4/"><![CDATA[<h3 id="the-player">The Player</h3> <p>this week I’m going to be developing the player. It’s not an AI or anything related to the assignment so I’ll be brief in this post, although it will be a VERY big part of my game!</p> <h2 id="the-scene">The Scene</h2> <p><img src="https://i.imgur.com/yvoCsaa.png" alt="Player"/> The player will be made up of a KinematicBody (perfect for moving objects), the collision shape will be a pill (which is very standard for modern games), a Camera that will be following the player at all times and finally the 3D model (along with its animations).</p> <h2 id="the-script">The Script</h2> <p>I’m going to run through how I made the script in order, here we go:</p> <h3 id="directional-input">Directional input</h3> <p>We’re going to store the direction the player is moving in a 3D Vector, 1 will be moving forward in that direction and -1 will be moving backwards, with 0 being not moving at all. When a key is pressed we set the Vector to its appropriate value for that axis, easy! When the key is released we have to make sure that the player is not moving in the other direction before we set the moving of that axis to 0! Now if we tell the player to move by that Vector every frame we can move around, it’s a bit fast and a bit jerky, so we’ll implement a velocity system next.</p> <h3 id="velocity-based-movement">Velocity based movement</h3> <p>We start by making a 3D Vector, we’ll also make some constants:</p> <ul> <li>Acceleration: the speed at which the player accelerates</li> <li>Deceleration: the speed at which the player decelerates</li> <li>max_speed: the maximum speed of the player Now, if the player is moving in a direction, we increase the velocity by acceleration until we hit the maximum speed, if it’s not we decrease it until it hits 0. We then move our player by our velocity multiplied by delta time, which will make the movement frame independent.</li> </ul> <h3 id="animation">Animation</h3> <p>When the player is moving, set the animation to the moving animation, if not set it to the idle. We’ll also rotate the player to look at the direction they’re facing.</p> <h3 id="damage">Damage</h3> <p>Finally, we have a function to call when the player is damaged. This could be anything, but I like the idea of the screen just going black when the player dies.</p>]]></content><author><name></name></author><category term="AI"/><category term="gamedev"/><summary type="html"><![CDATA[Fourth week of undergrad AI gamedev course]]></summary></entry></feed>